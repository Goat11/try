﻿![内存分区模型](https://img-blog.csdnimg.cn/4eb1520e5a4f44908878de7cfd71ac98.png#pic_center)

> 具体可见：[什么是代码区、常量区、静态区（全局区）、堆区、栈区？](https://blog.csdn.net/u014470361/article/details/79297601)
> 
![在这里插入图片描述](https://img-blog.csdnimg.cn/2138e59926e24a0c962ce633bc24feb8.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR09BVF8weDAy,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

## 1.代码区
存放cpu执行的机器语言代码

 - **可读的**

代码区和常量区均是只可读的内存空间[ROM(read only memory)]，不可修改的，ROM是永久存储的
而全局区 栈区 堆区均是随机存取且暂时型存储的内存空间，即RAM(Random Access memory)（断电就没的那种）

 - **共享的**


执行了一次之后生成了exe文件后，每次就用这片内存直接执行即可，不必再开辟一个区域来执行

  ## 2.全局区（global）(（静态区）（static）) 和 常量区

全局区存放**全局变量和静态变量**，常量区存放**常量和字符串常量**，系统在整个程序跑完后才释放内存。

> eg：某函数里有静态的局部变量，若对函数多次调用，并不会对该变量多次初始化，只初始化一次，因为内存不会释放。可应用在求阶乘中。

### 静态区的大小
所允许的空间大小取决于剩余内存的大小，也就是说，如果电脑剩余8G内存的话，int类型的二维数组甚至可以开到46340*46340的大小；

##   3.栈区（stack）

栈区存放局部变量（local）和形参变量，栈区就像是客栈，函数执行完后，系统会自动释放内存。
**栈内存分配运算内置于处理器的指令集中，效率很高**，但是分配的内存容量有限。
#### 3.1栈大小有限（且小）
在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，**在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数）**，如果申请的空间超过栈的剩余空间时，将提示overflow。
（1M即为2^20byte，大概是100w多byte，则最多开辟空间储存一个含25w多个int数据类型的数组）

```cpp
int main()
{
	//栈区
	int a[1000000];//这样就会报错

	//解决方法：可以在全局区或在堆区或自由存储区开辟空间存储
	
	//全局区
	static int a[1000000];
	//堆区
	int *a=(int*)malloc(sizeof(int)*1000000);
	free(a);
	//自由存储区
	int *a=new int[1000000];
	delete [] a;
}
```

#### 3.2不要返回局部变量的地址：
> 因为局部变量每次在函数运行完系统都会释放该地址内存，则该地址就不再存放之前的数据，可能是未知的东西



![（相关实例）](https://img-blog.csdnimg.cn/017c4bf95bc148d687ff0cc7d10ec681.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR09BVF8weDAy,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)


  ##  4.堆区（leap）和自由存储区

  

> **一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收** 。**分配方式类似于链表**,是不连续的。
亦称动态内存分配，动态内存的生存期由程序员决定，使用非常灵活，但**如果在堆上分配了空间**，**就有责任回收它**，否则运行的程序会出现**内存泄漏**，**频繁地分配和释放不同大小的堆空间**将会产生**堆内碎块**。
> 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。

malloc和new：[new delete和malloc、free的区别对比](https://blog.csdn.net/weixin_51966535/article/details/119988004)
 - 堆区（malloc）

> C中malloc分配的内存块。用free结束生命周期。

 - 自由存储区（new）

> 堆就是new出来的内存块，编译器不管释放，由应用程序控制，new对应delete。如果没释放掉，程序结束后，操作系统会自动回收。

#### “free store” VS “heap”

##### 堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。
##### 虽然自由存储区一般都是用堆来实现，但是堆与自由存储区并不等价，有时候自由存储区可能不是堆

> 基本上，所有的C++编译器**默认使用堆来实现自由存储**，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，**这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确**。
> 但**程序员也可以通过重载操作符**，**改用其他内存来实现自由存储，例如全局变量做的对象池**，**这时自由存储区就区别于堆了**

具体参考于：[此文章](https://www.cnblogs.com/QG-whz/p/5060894.html)

### 堆区的结构

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。
### 堆区的大小

**堆的大小受限于计算机系统中有效的虚拟内存**，由此可见，**堆获得的空间比较灵活，也比较大**。

> **32位系统下，堆内存可以达到4GB，** 理论上则是硬盘大小；
这里的大小限制是可用硬件与操作系统通过使用其他设备临时存储未使用的数据(即将页面移动到硬盘)来模拟空间的能力的组合。

## 5.另一种概念

![在这里插入图片描述](https://img-blog.csdnimg.cn/764930fc09734b4aa871713e9ef9b557.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR09BVF8weDAy,size_11,color_FFFFFF,t_70,g_se,x_16)

代码段
